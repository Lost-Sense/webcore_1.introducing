//Отличие примитивного типа от ссылочного
const obj1 = {
  x: 5
}
const obj2 = obj1;

obj2.x = 8;

console.log(obj1.x) //8, так как создавая obj2 мы по сути ссылаемся на obj1, соотвественно при изменении свойства x у obj2 мы меняем его у obj1 (ссылочный тип)

let a = 5;
let b = a;

b = 9;

console.log(a); // 5
console.log(b); // 9, (примитивный тип), так происходит, потому что при присваивании примитивного типа создается отдельная копия значения, сотвественно, если мы ссылаемся изначально на другой примитив, а затем переназначаем переменную, то изначальная переменная (в данном случае а) не изменяется в след за переменной b

//Приведение типов примитивов
console.log(true + false) // 1, числовое преобразование за счет математического оператора "+" (true = 1; false = 0; соответственно 1 + 0 = 1)
console.log(12 / "6") // 2, за счет числового преобразования (мат. оператор "/") строковое значение "6" считывается как числовое значение 6
console.log(12 < "6") //  false, так как происходит преобразование строки в число (в данном случае "6"), соответственно 12 > 6, следовательно выражение 12 < "6" неверно -> false
console.log("number" + 15 + 3) // number153, так как "number" не может быть переведен в число, 15 и 3 переводятся в строку и происходит конкатенация 
console.log(15 + 3 + "number") //18number, так как JS читает код слева направо, сначала он производит математическую операцию 15 + 3, затем происходит конкатенация (так как не может преобразовать строку в число)
console.log("foo" + +"bar") // fooNaN, так как сначала происходит числовое преобразование (за счет унарного оператора "+" перед выражением "bar"), за счет чего получаем NaN, после происходит конкатенация "foo" + "NaN" -> fooNaN
console.log('true' == true) // false, так как сначала происходит числовое преобразование операндов ("true" - строка и при переводе в число результат будет NaN, просто true - логическое значение и при преобразовании в число, результат будет 1), в результате мы получим вырожение NaN == 1 -> false
console.log(!!"false" == !!"true") // true, так как при преобразовании строки в логическое значение, а затем его двойной инверсии ("false" -> true, так как строка не пустая, а затем первая инверсия true -> false, после еще она инверсия false -> true) мы получаем выражение true == true -> true
console.log(false == 'false') // false, так как сначала происходит числовое преобразование операндов (где false становится 0, а строка "false" становпится NaN), затем получаем выражение 0 == NaN -> false
console.log(null == '') // false, так как null очень специфичен и равен (==) только себе или undefined, следовательно null == "" -> false
console.log(null > 0) // false
console.log(null == 0) // false, так как null по своей сути не является 0 впринципе, следовательно null == 0 -> false
console.log(null >= 0) // true
console.log(null == undefined) // true, так как исключение из правил
console.log(null === undefined) // false. так как null и undefined разные типы данных (при строгом сравнении сравниваются также типы данных)


//Приведение типов с объектами
console.log([1] > null) // true, так как в массиве только один элимент, который может быть преобразован в число, следовательно получаем выражение 1 > 0 -> true
console.log([1, 2] > null) // false, так как в массиве несколько элиментов, он не могут быть преобразованы в 1 число, следовательно при строчном преобразовании, а затем при числовом преобразовании результатом будет следующее выражение NaN > 0 -> false
console.log(['x'] == 'x') // true, так как преобразует массив в строчное значение, а после сравнивает эти значения, где "x" == "x" -> true
console.log([] + null + 1) // null1, так как сначала преобразуем массив в строчное значение и получаем "", затем складываем с null и получаем "null", затем складываем строку "null" и 1, но так как строка "null" не переводится в число, произойдет конкатенация и результат получится "null1"
console.log([1, 2, 3] == [1, 2, 3]) //
console.log([1, 2, 3] === [1, 2, 3]) // false, так как при строгом сравнении проверяется не только тип данных, но и ссылки на объекты, следовательно эти массивы не будут друг другу равны -> false
console.log({ a: 1 } - 1) // NaN, так как не получается преобразовать объект к числу, после оно преобразуется в строку "[object Object]", а после еще раз пытается преобразовать ее в число, что получается NaN, затем происходит вычетание из NaN 1, получаем выражение NaN - 1 -> NaN
console.log({ a: 1 } + 2) // "[object Object]2", тоже самое, но так как тут стоит оператор "+", происходит конкатенация на моменте преобразования объекта в строку, и мы получаем следующее "[object Object]" + "2" -> "[object Object]2"
